<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mining2D</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #000; overflow: hidden; font-family: 'Arial', sans-serif; user-select: none; -webkit-user-select: none; -moz-user-select: none; touch-action: none; }
        #gameContainer { position: relative; width: 100vw; height: 100vh; }
        canvas { display: block; background: #1a1a2e; image-rendering: pixelated; }
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; color: white; }
        .logo { position: absolute; top: 20px; left: 20px; font-size: 14px; font-weight: bold; color: #6e6e6a; letter-spacing: 3px; }
        .inventory-bar { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 10px; pointer-events: all; }
        .inv-slot { width: 60px; height: 60px; background: rgba(0,0,0,0.6); border: 2px solid #555; display: flex; align-items: center; justify-content: center; font-size: 30px; position: relative; border-radius: 5px; cursor: pointer; }
        .inv-slot.selected { border-color: #6a6; box-shadow: 0 0 10px #6a6; }
        #inventoryGrid { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(40, 40, 40, 0.9); border: 4px solid #222; padding: 15px; display: none; grid-template-columns: repeat(5, 65px); gap: 8px; pointer-events: all; border-radius: 5px; z-index: 500; }
        #inventoryGrid.show { display: grid; }
        .inv-slot-grid { width: 65px; height: 65px; background: #555; border: 2px solid #333; display: flex; align-items: center; justify-content: center; font-size: 30px; position: relative; cursor: pointer; }
        .inv-slot-grid:hover { background: #666; }
        .inv-slot-grid.hotbar-sync { border-color: #888; }
        .inv-count { position: absolute; bottom: 2px; right: 5px; font-size: 12px; font-weight: bold; pointer-events: none; }
        #dragSlot { position: fixed; pointer-events: none; z-index: 2000; font-size: 40px; display: none; transform: translate(-50%, -50%); }
        #pauseOverlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.7); backdrop-filter: blur(4px); display: none; align-items: center; justify-content: center; z-index: 1000; pointer-events: all; }
        #pauseOverlay.show { display: flex; }
        .pause-menu { background: #222; padding: 40px; border: 3px solid #555; border-radius: 15px; text-align: center; min-width: 300px; }
        .pause-menu button { padding: 12px 30px; background: #4a4; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
        .block-icon { width: 32px; height: 32px; border: 1px solid rgba(0,0,0,0.2); box-shadow: inset -2px -2px 0px rgba(0,0,0,0.3); }
        .stick { background: #6d4c41; box-shadow: 4px -4px 0 #6d4c41, 8px -8px 0 #6d4c41, -4px 4px 0 #6d4c41; transform: rotate(45deg); }
        .torch-inv { background: #6d4c41; box-shadow: 0 -4px 0 #6d4c41, 0 -8px 0 #6d4c41, 0 -12px 0 #333; top: 5px; }
        .pixel-icon { width: 32px; height: 32px; position: relative; image-rendering: pixelated; display: flex; align-items: center; justify-content: center; }
        .icon-stick::before { content: ""; position: absolute; width: 4px; height: 24px; background: #6d4c41; transform: rotate(45deg); box-shadow: 2px 2px 0 rgba(0,0,0,0.2); }
        .icon-torch::before { content: ""; position: absolute; width: 4px; height: 20px; background: #6d4c41; bottom: 4px; }
        .icon-torch::after { content: ""; position: absolute; width: 6px; height: 6px; background: #333; top: 4px; }
        .icon-ladder::before { content: ""; position: absolute; width: 3px; height: 28px; background: #8b6f47; left: 8px; }
        .icon-ladder::after { content: ""; position: absolute; width: 3px; height: 28px; background: #8b6f47; right: 8px; }
        .icon-ladder { background: linear-gradient(to bottom, transparent 20%, #6d5435 20%, #6d5435 30%, transparent 30%, transparent 45%, #6d5435 45%, #6d5435 55%, transparent 55%, transparent 70%, #6d5435 70%, #6d5435 80%, transparent 80%); }
        .icon-sapling::before { content: ""; position: absolute; width: 4px; height: 16px;  background: #5d4037; bottom: 4px; left: 50%; transform: translateX(-50%); }
.icon-sapling::after { content: ""; position: absolute; width: 20px; height: 12px; background: #4caf50; border-radius: 50% 50% 0 0; top: 4px; left: 50%; transform: translateX(-50%); box-shadow: inset -2px -2px 0 rgba(0,0,0,0.2); }
        #tooltip { position: fixed; pointer-events: none; background: rgba(0,0,0,0.8); color: white; padding: 5px 10px; border-radius: 4px; border: 1px solid #777; font-size: 14px; display: none; z-index: 3000; }
        #craftingPanel { display: none; position: absolute; top: 50%; left: calc(50% + 200px); transform: translateY(-50%);  background: rgba(40,40,40,0.95); border: 4px solid #222; padding: 20px; color: white; pointer-events: all; border-radius: 5px; min-width: 280px; }
        #craftingGrid { display: grid; grid-template-columns: repeat(3, 60px); gap: 5px; margin: 15px 0; }
        .craft-slot { width: 60px; height: 60px; background: rgba(0,0,0,0.5); border: 2px solid #555; display: flex; align-items: center; justify-content: center; font-size: 30px; position: relative; cursor: pointer; border-radius: 3px; }
        .craft-slot:hover { background: rgba(0,0,0,0.7); border-color: #777; }
        #craftOutput { display: flex; align-items: center; gap: 15px; margin-top: 15px; padding-top: 15px; border-top: 2px solid #555; }
        #craftOutputSlot { width: 60px; height: 60px; background: rgba(50,80,50,0.5); border: 2px solid #6a6; display: flex; align-items: center; justify-content: center; font-size: 30px; position: relative; cursor: pointer; border-radius: 3px; }
        #craftOutputSlot:hover { background: rgba(50,80,50,0.7); }
        #craftButton { padding: 10px 20px; background: #4a4; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; font-size: 14px; }
        #craftButton:disabled { background: #555; cursor: not-allowed; opacity: 0.5; }
    </style>
</head>
<body>

<div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    <div id="dragSlot"></div>
    <div id="ui">
        <div class="logo">MINING2D v0.13</div>
        <div class="inventory-bar" id="inventoryBar"></div>
        <div id="inventoryGrid"></div>
        <div id="craftingPanel">
            <h3 style="margin-bottom:10px; border-bottom:1px solid #555;">Crafting</h3>
            <div id="craftingGrid"></div>
            <div id="craftOutput">
                <div id="craftOutputSlot"></div>
                <button id="craftButton" disabled>CRAFT</button>
            </div>
        </div>
        <div id="tooltip"></div>
        <div id="pauseOverlay">
            <div class="pause-menu">
                <h1>PAUSE</h1>
                <span> Open Source mining game v0.13</span>
                <div style="margin: 20px 0; padding: 15px; background: rgba(255,255,255,0.05); border-radius: 8px;">
                    <p style="margin-bottom: 10px; color: #aaa; font-size: 14px;">CONFIGURATION DU MONDE</p>
                    
                    <input type="number" id="seedInput" placeholder="Entrez un seed..." 
                           style="padding: 10px; width: 100%; border-radius: 5px; border: 1px solid #444; background: #111; color: white; margin-bottom: 10px;">
                    
                    <div style="display: flex; gap: 10px; justify-content: center;">
                        <button onclick="game.regenerateWorld(document.getElementById('seedInput').value)" style="background: #44a;">APPLIQUER SEED</button>
                        <button onclick="game.regenerateWorld(Math.floor(Math.random() * 999999))" style="background: #844;">ALÉATOIRE</button>
                    </div>
                </div>
                <button onclick="game.togglePause()" style="width: 100%;">REPRENDRE</button>
            </div>
        </div>
    </div>
</div>

<script>
/**
 * Constantes du jeu
 */
const CONSTANTS = {
    BLOCK_SIZE: 32,
    CHUNK_WIDTH: 16,
    WORLD_SEED: 123456,
    WORLD_HEIGHT: 80,
    PLAYER_WIDTH: 0.75,
    PLAYER_HEIGHT: 0.75,
    GRAVITY: 0.02,
    SPEED: 0.12,
    JUMP_FORCE: -0.18,
    MINING_COOLDOWN: 15,
    REACH_DISTANCE: 4.5,
    TORCH_LIGHT_RADIUS: 150,
    PLAYER_LIGHT_RADIUS: 220,
    INVENTORY_SIZE: 20,
    HOTBAR_SIZE: 5,
    SEED_MULTIPLIERS: {
        GROUND: 100,
        ORE: 1000,
        IRON: 1500,
        TREE: 50,
        CAVE: 3000,
        CAVE_DETAIL: 5000
    },
    CAVE: {
        FREQUENCY: 0.04,      // Fréquence des grottes
        THRESHOLD: 0.35,      // Seuil de creusage (0-1)
        DETAIL_SCALE: 0.12,    // Détails des grottes
        MIN_DEPTH: 3,         // Profondeur minimale
        MAX_DEPTH: 60         // Profondeur maximale
    }
};

/**
 * Types de blocs et leurs propriétés
 */
const BLOCK_TYPES = {
    0: { name: 'Air', color: null, solid: false },
    1: { name: 'Terre', color: '#5d4e37', solid: true },
    2: { name: 'Pierre', color: '#666', solid: true },
    3: { name: 'Herbe', color: '#4caf50', solid: true },
    4: { name: 'Diamant', color: '#ffd700', solid: true },
    5: { name: 'Bois', color: '#795548', solid: true },
    6: { name: 'Feuilles', color: '#2e7d32', solid: false },
    7: { name: 'Charbon', color: '#333', solid: true },
    8: { name: 'Fer', color: '#d4af89', solid: true },
    9: { name: 'Planches', color: '#a67c52', solid: true },
    10: { name: 'Bâton', color: '#8b4513', solid: false, isItem: true },
    11: { name: 'Torche', color: '#ffcc00', solid: false, light: true },
    12: { name: 'Bouture', color: '#2e7d32', solid: false },
    13: { name: 'Échelle', color: '#8b6f47', solid: false, climbable: true },
    14: { name: 'Four', color: '#383736', solid: true },
    99: { name: 'Bedrock', color: '#111', solid: true, unbreakable: true }
};

/**
 * Recettes de craft avec patterns 3x3
 * null = case vide, number = ID du bloc requis
 */
const RECIPES = [
    {
        name: 'Planches (x8)',
        pattern: [
            [5, null, null],
            [null, null, null],
            [null, null, null]
        ],
        output: { id: 9, count: 8 }
    },
    {
        name: 'Bâtons (x4)',
        pattern: [
            [9, null, null],
            [9, null, null],
            [null, null, null]
        ],
        output: { id: 10, count: 4 }
    },
    {
        name: 'Torches (x4)',
        pattern: [
            [7, null, null],
            [10, null, null],
            [null, null, null]
        ],
        output: { id: 11, count: 4 }
    },
    {
        name: 'Échelle (x3)',
        pattern: [
            [10, null, 10],
            [10, 10, 10],
            [10, null, 10]
        ],
        output: { id: 13, count: 3 }
    },
    {
        name: 'Bouture (x2)',
        pattern: [
            [6, 6, 6],
            [6, 6, 6],
            [6, 6, 6]
        ],
        output: { id: 12, count: 2 }
    },
    {
        name: 'Four',
        pattern: [
            [2, 2, 2],
            [2, null, 2],
            [2, 2, 2]
        ],
        output: { id: 14, count: 1 }
    }
];

/**
 * Générateur de bruit de Perlin simplifié pour les grottes
 */
class SimpleNoise {
    constructor(seed = 0) {
        this.perm = new Uint8Array(512);
        const random = this.seededRandom(seed);

        for (let i = 0; i < 256; i++) this.perm[i] = i;
        for (let i = 0; i < 256; i++) {
            const j = Math.floor(random() * 256);
            [this.perm[i], this.perm[j]] = [this.perm[j], this.perm[i]];
            this.perm[i + 256] = this.perm[i];
        }
    }
    
    seededRandom(seed) {
        let x = seed;
        return () => {
            x = Math.sin(x++) * 10000;
            return x - Math.floor(x);
        };
    }

    fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
    lerp(t, a, b) { return a + t * (b - a); }
    grad(hash, x, y) {
        const h = hash & 15;
        const u = h < 8 ? x : y;
        const v = h < 4 ? y : h === 12 || h === 14 ? x : 0;
        return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
    }

    noise(x, y) {
        const X = Math.floor(x) & 255;
        const Y = Math.floor(y) & 255;
        x -= Math.floor(x);
        y -= Math.floor(y);
        const u = this.fade(x);
        const v = this.fade(y);
        const A = this.perm[X] + Y, B = this.perm[X + 1] + Y;
        
        return this.lerp(v, 
            this.lerp(u, this.grad(this.perm[A], x, y), this.grad(this.perm[B], x - 1, y)),
            this.lerp(u, this.grad(this.perm[A + 1], x, y - 1), this.grad(this.perm[B + 1], x - 1, y - 1))
        );
    }

    // Bruit fractal (octaves)
    fractalNoise(x, y, octaves = 3, persistence = 0.5) {
        let total = 0;
        let frequency = 1;
        let amplitude = 1;
        let maxValue = 0;
        
        for (let i = 0; i < octaves; i++) {
            total += this.noise(x * frequency, y * frequency) * amplitude;
            maxValue += amplitude;
            amplitude *= persistence;
            frequency *= 2;
        }
        
        return total / maxValue;
    }
}

/**
 * Gestionnaire de chunks - gère la génération et le stockage des chunks
 */
class ChunkManager {
    constructor(seed = CONSTANTS.WORLD_SEED) {
        this.seed = seed;
        this.chunks = new Map();
        this.caveNoise = new SimpleNoise(seed + 1);
        this.detailNoise = new SimpleNoise(seed + 2);
    }

    /**
     * Génère un chunk à la position donnée
     */
    generate(chunkX) {
        const chunk = this.createBaseTerrain(chunkX);
        this.addCaves(chunk, chunkX);  // NOUVEAU : Grottes
        this.addOreVeins(chunk, chunkX);
        this.addTrees(chunk, chunkX);
        return chunk;
    }

    hash2D(x, y, seed = 1337) {
        let h = x * 374761393 + y * 668265263 + seed * 144665;
        h = (h ^ (h >> 13)) * 1274126177;
        return ((h ^ (h >> 16)) >>> 0) / 4294967295;
    }

    /**
     * Crée le terrain de base (terre, pierre, herbe)
     */
    createBaseTerrain(chunkX) {
        const chunk = [];
        const baseX = chunkX * CONSTANTS.CHUNK_WIDTH;
        
        for (let localX = 0; localX < CONSTANTS.CHUNK_WIDTH; localX++) {
            const x = baseX + localX;
            const column = [];
            const groundLevel = Math.floor(35 + Math.sin(x/10)*5);
            
            for (let y = 0; y < CONSTANTS.WORLD_HEIGHT; y++) {
                column[y] = this.getBlockForDepth(y, groundLevel, x, y);
            }
            chunk.push(column);
        }
        return chunk;
    }

    /**
     * Détermine le type de bloc selon la profondeur
     */
    getBlockForDepth(y, groundLevel, x, worldY) {
        if (y >= CONSTANTS.WORLD_HEIGHT - 2) return 99; // Bedrock
        if (y === groundLevel) return 3; // Herbe
        if (y > groundLevel) {
            const depth = y - groundLevel;
            if (depth > 1 && depth <= 6) {
                return this.seededRandom(x * CONSTANTS.SEED_MULTIPLIERS.GROUND + worldY * 200) < (depth - 1) / 5 ? 2 : 1;
            }
            if (depth > 6) return 2; // Pierre profonde
            return 1; // Terre
        }
        return 0; // Air
    }

    /**
     * AJOUTE DES GROTTES NATURELLES
     */
addCaves(chunk, chunkX) {
    const baseX = chunkX * CONSTANTS.CHUNK_WIDTH;

    for (let localX = 0; localX < CONSTANTS.CHUNK_WIDTH; localX++) {
        const worldX = baseX + localX;
        const groundLevel = Math.floor(35 + Math.sin(worldX / 10) * 5);

        for (let y = 0; y < CONSTANTS.WORLD_HEIGHT; y++) {

            if (chunk[localX][y] !== 2) continue;

            const depth = y - groundLevel;
            if (depth < CONSTANTS.CAVE.MIN_DEPTH) continue;
            if (depth > CONSTANTS.CAVE.MAX_DEPTH) continue;

            let threshold = CONSTANTS.CAVE.THRESHOLD;
            if (depth < 6) threshold = 0.15;

            const caveValue = this.caveNoise.fractalNoise(
                worldX * CONSTANTS.CAVE.FREQUENCY,
                y * CONSTANTS.CAVE.FREQUENCY,
                3,
                0.5
            );

            const detailValue = this.detailNoise.noise(
                worldX * CONSTANTS.CAVE.DETAIL_SCALE,
                y * CONSTANTS.CAVE.DETAIL_SCALE
            );

            const finalValue = caveValue + detailValue * 0.3;
            const normalized = (finalValue + 1) / 2;

            if (normalized < threshold) {
                chunk[localX][y] = 0;
            }
        }
    }
}


    /**
     * Ajoute les filons de minerai (VERSION CORRIGÉE - pas de diagonales)
     */
addOreVeins(chunk, chunkX) {
    const baseX = chunkX * CONSTANTS.CHUNK_WIDTH;

    for (let localX = 0; localX < CONSTANTS.CHUNK_WIDTH; localX++) {
        const x = baseX + localX;

        for (let y = 0; y < CONSTANTS.WORLD_HEIGHT; y++) {
            if (chunk[localX][y] !== 2) continue;

            // Charbon
            if (this.hash2D(x, y, 7) < 0.02) {
                this.placeOreVein(chunk, chunkX, x, y, 7, 3, 3);
            }

            // Fer
            if (this.hash2D(x, y, 8) < 0.015) {
                this.placeOreVein(chunk, chunkX, x, y, 8, 2, 2);
            }
        }
    }
}

    /**
     * Place une veine de minerai sans créer de patterns diagonaux
     */
    placeOreVein(chunk, chunkX, startX, startY, oreId, width, height) {
        for (let dx = 0; dx < width; dx++) {
            for (let dy = 0; dy < height; dy++) {
                const worldX = startX + dx;
                const worldY = startY + dy;
                
                // Calculer dans quel chunk on est
                const targetChunkX = Math.floor(worldX / CONSTANTS.CHUNK_WIDTH);
                const targetLocalX = ((worldX % CONSTANTS.CHUNK_WIDTH) + CONSTANTS.CHUNK_WIDTH) % CONSTANTS.CHUNK_WIDTH;
                
                // Ne modifier que si dans le chunk actuel
                if (targetChunkX !== chunkX) continue;
                if (worldY >= CONSTANTS.WORLD_HEIGHT) continue;
                if (!chunk[targetLocalX]) continue;
                if (chunk[targetLocalX][worldY] !== 2) continue;
                
                // Probabilité basée sur la position monde (pas de pattern diagonal)
                if (this.seededRandom(worldX * 111 + worldY * 222) > 0.3) {
                    chunk[targetLocalX][worldY] = oreId;
                }
            }
        }
    }

    /**
     * Ajoute les arbres
     */
    addTrees(chunk, chunkX) {
        const baseX = chunkX * CONSTANTS.CHUNK_WIDTH;
        
        for (let localX = 0; localX < CONSTANTS.CHUNK_WIDTH; localX++) {
            const x = baseX + localX;
            const groundLevel = Math.floor(35 + Math.sin(x/10)*5);
            
            if (chunk[localX][groundLevel] === 3 && this.seededRandom(x * 50) < 0.08) {
                this.generateTree(chunk, localX, groundLevel, x);
            }
        }
    }

    /**
     * Génère un arbre à la position donnée
     */
    generateTree(chunk, localX, groundLevel, seed) {
        const trunkHeight = 4 + Math.floor(this.seededRandom(seed * 75) * 2);
        
        // Tronc
        for (let i = 0; i < trunkHeight; i++) {
            const y = groundLevel - 1 - i;
            if (y > 0) chunk[localX][y] = 5;
        }
        
        // Feuilles
        const leafTop = groundLevel - 1 - trunkHeight;
        for (let lx = -2; lx <= 2; lx++) {
            for (let ly = -2; ly <= 1; ly++) {
                const targetX = localX + lx;
                const targetY = leafTop + ly;
                if (targetX >= 0 && targetX < CONSTANTS.CHUNK_WIDTH && 
                    targetY >= 0 && 
                    chunk[targetX]?.[targetY] === 0 && 
                    Math.sqrt(lx*lx + ly*ly) <= 2.2) {
                    chunk[targetX][targetY] = 6;
                }
            }
        }
    }

    /**
     * Générateur de nombres pseudo-aléatoires déterministe
     */
    seededRandom(seed) {
        const x = Math.sin(seed + this.seed) * 10000;
        return x - Math.floor(x);
    }

    /**
     * Récupère ou génère un chunk
     */
    get(chunkX) {
        if (!this.chunks.has(chunkX)) {
            this.chunks.set(chunkX, this.generate(chunkX));
        }
        return this.chunks.get(chunkX);
    }

    /**
     * Convertit les coordonnées monde en coordonnées chunk
     */
    worldToChunk(worldX) {
        const chunkX = Math.floor(worldX / CONSTANTS.CHUNK_WIDTH);
        const localX = ((worldX % CONSTANTS.CHUNK_WIDTH) + CONSTANTS.CHUNK_WIDTH) % CONSTANTS.CHUNK_WIDTH;
        return { chunkX, localX };
    }

    /**
     * Récupère l'ID d'un bloc aux coordonnées monde
     */
    getBlockId(worldX, worldY) {
        if (worldY < 0 || worldY >= CONSTANTS.WORLD_HEIGHT) return 0;
        const { chunkX, localX } = this.worldToChunk(worldX);
        const chunk = this.get(chunkX);
        return chunk[localX]?.[worldY] || 0;
    }

    /**
     * Définit l'ID d'un bloc aux coordonnées monde
     */
    setBlockId(worldX, worldY, blockId) {
        if (worldY < 0 || worldY >= CONSTANTS.WORLD_HEIGHT) return;
        const { chunkX, localX } = this.worldToChunk(worldX);
        const chunk = this.get(chunkX);
        if (chunk[localX]) {
            chunk[localX][worldY] = blockId;
        }
    }
}

/**
 * Gestionnaire d'inventaire - gère les items et le drag & drop
 */
class InventoryManager {
    constructor(size, hotbarSize) {
        this.slots = Array(size).fill(null);
        this.size = size;
        this.hotbarSize = hotbarSize;
        this.selectedSlot = 0;
        this.draggedItem = null;
    }

    /**
     * Ajoute un item à l'inventaire
     */
    addItem(id, count) {
        const existing = this.slots.find(slot => slot && slot.id === id);
        if (existing) {
            existing.count += count;
            return true;
        }
        
        const emptyIndex = this.slots.indexOf(null);
        if (emptyIndex !== -1) {
            this.slots[emptyIndex] = { id, count };
            return true;
        }
        return false; // Inventaire plein
    }

    /**
     * Consomme un item de l'inventaire
     */
    consumeItem(id, count) {
        const item = this.slots.find(s => s && s.id === id);
        if (!item || item.count < count) return false;
        
        item.count -= count;
        if (item.count <= 0) {
            const idx = this.slots.indexOf(item);
            this.slots[idx] = null;
        }
        return true;
    }

    /**
     * Vérifie si l'inventaire contient suffisamment d'un item
     */
    hasItem(id, count) {
        const item = this.slots.find(s => s && s.id === id);
        return item && item.count >= count;
    }

    /**
     * Gère le clic sur un slot (drag & drop)
     * clickType: 'left' = clic gauche, 'right' = clic droit, 'middle' = clic molette
     */
    handleSlotClick(index, clickType = 'left') {
        const slotContent = this.slots[index];
        
        if (clickType === 'middle' && slotContent && !this.draggedItem) {
            // Clic molette : diviser le stack en deux
            const halfCount = Math.floor(slotContent.count / 2);
            if (halfCount > 0) {
                this.draggedItem = { id: slotContent.id, count: halfCount };
                slotContent.count -= halfCount;
                if (slotContent.count <= 0) {
                    this.slots[index] = null;
                }
            }
            return true;
        }
        
        if (clickType === 'right') {
            if (this.draggedItem && !slotContent) {
                // Clic droit : déposer un seul item
                this.slots[index] = { id: this.draggedItem.id, count: 1 };
                this.draggedItem.count--;
                if (this.draggedItem.count <= 0) {
                    this.draggedItem = null;
                }
                return true;
            } else if (this.draggedItem && slotContent && slotContent.id === this.draggedItem.id) {
                // Clic droit sur stack existant : ajouter 1
                slotContent.count++;
                this.draggedItem.count--;
                if (this.draggedItem.count <= 0) {
                    this.draggedItem = null;
                }
                return true;
            } else if (!this.draggedItem && slotContent) {
                // Clic droit sur un slot plein : prendre la moitié
                const halfCount = Math.ceil(slotContent.count / 2);
                this.draggedItem = { id: slotContent.id, count: halfCount };
                slotContent.count -= halfCount;
                if (slotContent.count <= 0) {
                    this.slots[index] = null;
                }
                return true;
            }
        }
        
        // Clic gauche (comportement par défaut)
        if (!this.draggedItem && slotContent) {
            // Prendre l'item
            this.draggedItem = slotContent;
            this.slots[index] = null;
            return true;
        } else if (this.draggedItem) {
            if (slotContent && slotContent.id === this.draggedItem.id) {
                // Empiler
                slotContent.count += this.draggedItem.count;
                this.draggedItem = null;
            } else {
                // Échanger
                this.slots[index] = this.draggedItem;
                this.draggedItem = slotContent;
            }
            return true;
        }
        return false;
    }

    /**
     * Récupère l'item sélectionné dans la hotbar
     */
    getSelectedItem() {
        return this.slots[this.selectedSlot];
    }

    /**
     * Change le slot sélectionné
     */
    changeSelection(delta) {
        this.selectedSlot = (this.selectedSlot + delta + this.hotbarSize) % this.hotbarSize;
    }
}

/**
 * Système de rendu - gère l'affichage
 */
class Renderer {
    constructor(canvas, game) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.game = game;
        this.tempCanvas = null;
        this.stars = this.generateStars(100);
    }

    /**
     * Génère les étoiles de fond
     */
    generateStars(count) {
        return Array.from({ length: count }, () => ({
            x: Math.random() * window.innerWidth,
            y: Math.random() * window.innerHeight,
            size: Math.random() * 2,
            speed: 0.1 + Math.random() * 0.3
        }));
    }

    /**
     * Redimensionne le canvas
     */
    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        this.viewWidth = Math.ceil(this.canvas.width / CONSTANTS.BLOCK_SIZE);
        this.viewHeight = Math.ceil(this.canvas.height / CONSTANTS.BLOCK_SIZE);
        
        // Recréer le canvas temporaire pour le fog
        this.tempCanvas = document.createElement('canvas');
        this.tempCanvas.width = this.canvas.width;
        this.tempCanvas.height = this.canvas.height;
    }

    /**
     * Rendu principal
     */
    render(camera, player, chunkManager, inventory, saplings) {
        this.clear();
        this.drawBackground(camera);
        this.drawWorld(camera, chunkManager);
        this.drawDroppedItems(camera, this.game.droppedItems);
        this.drawLighting(camera, player, chunkManager);
        this.drawPlayer(player, camera, inventory);
    }

    clear() {
        this.ctx.fillStyle = '#050510';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    }

    drawBackground(camera) {
        this.ctx.fillStyle = "white";
        this.stars.forEach(star => {
            let sx = (star.x - camera.x * star.speed * 10) % this.canvas.width;
            let sy = (star.y - camera.y * star.speed * 10) % this.canvas.height;
            if (sx < 0) sx += this.canvas.width;
            if (sy < 0) sy += this.canvas.height;
            
            this.ctx.beginPath();
            this.ctx.arc(sx, sy, star.size, 0, Math.PI * 2);
            this.ctx.fill();
        });
    }

    drawWorld(camera, chunkManager) {
        // Calculer l'offset sub-pixel pour la fluidité
        const offsetX = camera.x * CONSTANTS.BLOCK_SIZE;
        const offsetY = camera.y * CONSTANTS.BLOCK_SIZE;
        
        const startX = Math.floor(camera.x);
        const startY = Math.floor(camera.y);
        
        for (let x = startX; x < startX + this.viewWidth + 1; x++) {
            for (let y = startY; y < startY + this.viewHeight + 1; y++) {
                const id = chunkManager.getBlockId(x, y);
                if (id === 0) continue;

                // Calcul fluide sans arrondir la caméra
                const screenX = Math.floor(x * CONSTANTS.BLOCK_SIZE - offsetX);
                const screenY = Math.floor(y * CONSTANTS.BLOCK_SIZE - offsetY);

                if (id === 11) {
                    this.drawTorch(screenX, screenY, x, y);
                } else if (id === 12) {
                    this.drawSapling(screenX, screenY);
                } else if (id === 13) {
                    this.drawLadder(screenX, screenY);
                } else {
                    this.ctx.fillStyle = BLOCK_TYPES[id].color;
                    this.ctx.fillRect(screenX, screenY, CONSTANTS.BLOCK_SIZE, CONSTANTS.BLOCK_SIZE);
                }
            }
        }
    }

    drawLadder(screenX, screenY) {
        // Montants verticaux
        this.ctx.fillStyle = '#8b6f47';
        this.ctx.fillRect(screenX + 4, screenY, 6, CONSTANTS.BLOCK_SIZE);
        this.ctx.fillRect(screenX + 22, screenY, 6, CONSTANTS.BLOCK_SIZE);
        
        // Barreaux horizontaux
        this.ctx.fillStyle = '#6d5435';
        this.ctx.fillRect(screenX + 4, screenY + 6, 24, 4);
        this.ctx.fillRect(screenX + 4, screenY + 16, 24, 4);
        this.ctx.fillRect(screenX + 4, screenY + 26, 24, 4);
    }

    drawSapling(screenX, screenY) {
        const bSize = CONSTANTS.BLOCK_SIZE;
        // Tige
        this.ctx.fillStyle = '#5d4037'; 
        this.ctx.fillRect(screenX + bSize/2 - 1, screenY + bSize - 8, 2, 8);
        // Feuilles (Vert clair)
        this.ctx.fillStyle = '#8bc34a';
        this.ctx.fillRect(screenX + bSize/2 - 4, screenY + bSize - 10, 4, 3);
        this.ctx.fillRect(screenX + bSize/2 + 1, screenY + bSize - 12, 4, 3);
    }
    
    drawDroppedItems(camera, droppedItems) {
        const offsetX = camera.x * CONSTANTS.BLOCK_SIZE;
        const offsetY = camera.y * CONSTANTS.BLOCK_SIZE;

        droppedItems.forEach(item => {
            const screenX = Math.floor(item.x * CONSTANTS.BLOCK_SIZE - offsetX);
            const screenY = Math.floor(item.y * CONSTANTS.BLOCK_SIZE - offsetY);

            // Animation de rebond subtile
            const bounce = Math.sin(Date.now() / 200) * 2;

            // Dessiner l'item (version miniature)
            const size = 12;
            this.ctx.save();
            this.ctx.translate(screenX, screenY + bounce);
            
            // Rotation lente
            const rotation = (Date.now() / 1000) % (Math.PI * 2);
            this.ctx.rotate(rotation);

            if (item.id === 10) {
                // Bâton
                this.ctx.fillStyle = '#6d4c41';
                this.ctx.fillRect(-size/2, -size/2, 3, size);
            } else if (item.id === 11) {
                // Torche
                this.ctx.fillStyle = '#6d4c41';
                this.ctx.fillRect(-size/3, -size/2, 3, size - 2);
                this.ctx.fillStyle = '#333';
                this.ctx.fillRect(-size/3, -size/2 - 2, 3, 2);
            } else if (item.id === 13) {
                // Échelle
                this.ctx.fillStyle = '#8b6f47';
                this.ctx.fillRect(-size/2, -size/2, 2, size);
                this.ctx.fillRect(size/2 - 2, -size/2, 2, size);
                this.ctx.fillStyle = '#6d5435';
                this.ctx.fillRect(-size/2, -2, size, 2);
                this.ctx.fillRect(-size/2, 3, size, 2);
            } else {
                // Bloc standard
                this.ctx.fillStyle = BLOCK_TYPES[item.id].color;
                this.ctx.fillRect(-size/2, -size/2, size, size);
            }

            this.ctx.restore();
        });
    }

    drawTorch(screenX, screenY, worldX, worldY) {
        // Bâton
        this.ctx.fillStyle = '#6d4c41';
        this.ctx.fillRect(screenX + 12, screenY + 12, 8, 20);

        // Mèche
        this.ctx.fillStyle = '#333';
        this.ctx.fillRect(screenX + 12, screenY + 8, 8, 4);

        // Animation de la flamme
        const offset = (worldX * 7919 + worldY * 104729);
        const flicker = Math.floor(Math.sin((Date.now() + offset) / 150) * 3);

        // Flamme
        this.ctx.fillStyle = '#ff9800';
        this.ctx.fillRect(screenX + 10, screenY + 2 + flicker, 12, 8 - flicker);
        
        this.ctx.fillStyle = '#ffff00';
        this.ctx.fillRect(screenX + 14, screenY + 4 + flicker, 4, 4 - flicker);
    }

    drawLighting(camera, player, chunkManager) {
        const offsetX = camera.x * CONSTANTS.BLOCK_SIZE;
        const offsetY = camera.y * CONSTANTS.BLOCK_SIZE;
        
        const px = Math.floor(player.x * CONSTANTS.BLOCK_SIZE - offsetX);
        const py = Math.floor(player.y * CONSTANTS.BLOCK_SIZE - offsetY);

        const tempCtx = this.tempCanvas.getContext('2d');
        
        // Réinitialiser le canvas temporaire - FOG DE BASE
        tempCtx.globalCompositeOperation = 'source-over';
        tempCtx.fillStyle = 'rgba(0, 0, 0, 0.92)';
        tempCtx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Passer en mode "gomme" pour percer le noir
        tempCtx.globalCompositeOperation = 'destination-out';

        // Lumière du joueur
        this.drawLightSource(tempCtx, px, py + 12, CONSTANTS.PLAYER_LIGHT_RADIUS);

        // Lumière des torches
        const flicker = Math.sin(Date.now() / 100) * 3;
        const startX = Math.floor(camera.x);
        const startY = Math.floor(camera.y);
        
        for (let x = startX; x < startX + this.viewWidth + 1; x++) {
            for (let y = startY; y < startY + this.viewHeight + 1; y++) {
                if (chunkManager.getBlockId(x, y) === 11) {
                    const tx = Math.floor(x * CONSTANTS.BLOCK_SIZE - offsetX) + 16;
                    const ty = Math.floor(y * CONSTANTS.BLOCK_SIZE - offsetY) + 16;
                    this.drawLightSource(tempCtx, tx, ty, CONSTANTS.TORCH_LIGHT_RADIUS + flicker);
                }
            }
        }

        // Appliquer le fog
        this.ctx.drawImage(this.tempCanvas, 0, 0);
    }

    drawLightSource(ctx, x, y, radius) {
        const gradient = ctx.createRadialGradient(x, y, 30, x, y, radius);
        gradient.addColorStop(0, 'rgba(0, 0, 0, 1)');
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();
    }

    drawPlayer(player, camera, inventory) {
        const offsetX = camera.x * CONSTANTS.BLOCK_SIZE;
        const offsetY = camera.y * CONSTANTS.BLOCK_SIZE;
        
        const px = Math.floor(player.x * CONSTANTS.BLOCK_SIZE - offsetX);
        const py = Math.floor(player.y * CONSTANTS.BLOCK_SIZE - offsetY);
        const pSize = Math.floor(player.width * CONSTANTS.BLOCK_SIZE);
        const pHeight = Math.floor(player.height * CONSTANTS.BLOCK_SIZE);

        this.ctx.save();

        // 1. On déplace le contexte au niveau des PIEDS du joueur (le pivot)
        this.ctx.translate(px, py + pHeight);

        // 2. On applique l'échelle (si player.scaleX n'existe pas encore, on met 1 par défaut)
        const sx = player.scaleX || 1;
        const sy = player.scaleY || 1;
        this.ctx.scale(sx, sy);

        // 3. On dessine les parties du corps par rapport au nouveau point (0,0) qui est aux pieds
        // On remonte de pHeight pour dessiner le haut
        
        // Head (Tête)
        this.ctx.fillStyle = '#bbb';
        this.ctx.fillRect(-pSize / 2, -pHeight, pSize, 12);
        
        // Body (Corps)
        this.ctx.fillStyle = '#6a4';
        this.ctx.fillRect(-pSize / 2, -pHeight + 12, pSize, 12);

        // Item en main
        const selectedItem = inventory.getSelectedItem();
        if (selectedItem) {
            // On ajuste la position car on est dans le repère transformé
            this.drawHeldItem(0, -pHeight + 10, selectedItem.id);
        }

        this.ctx.restore();
    }

    drawHeldItem(x, y, itemId) {
        this.ctx.save();
        this.ctx.translate(x, y);

        switch (itemId) {
            case 10: // Bâton
                this.ctx.rotate(Math.PI / 4);
                this.ctx.fillStyle = '#6d4c41';
                this.ctx.fillRect(0, -12, 4, 24);
                break;
            case 11: // Torche
                this.ctx.fillStyle = '#6d4c41';
                this.ctx.fillRect(4, -10, 4, 15);
                this.ctx.fillStyle = '#333';
                this.ctx.fillRect(4, -14, 4, 4);
                break;
            case 12: // sapling
                this.ctx.fillStyle = '#4d2c12';
                this.ctx.fillRect(4, -10, 4, 15);
                this.ctx.fillStyle = '#499946'; //vert
                this.ctx.fillRect(2, -14, 8, 8);
                break;
            case 13: // Échelle
                this.ctx.fillStyle = '#8b6f47';
                this.ctx.fillRect(2, -8, 3, 16);
                this.ctx.fillRect(10, -8, 3, 16);
                this.ctx.fillStyle = '#6d5435';
                this.ctx.fillRect(2, -6, 11, 2);
                this.ctx.fillRect(2, 0, 11, 2);
                this.ctx.fillRect(2, 6, 11, 2);
                break;
            default: // Bloc
                this.ctx.fillStyle = BLOCK_TYPES[itemId].color;
                this.ctx.fillRect(4, -4, 12, 12);
        }
        
        this.ctx.restore();
    }
}

/**
 * Gestionnaire d'entrées - clavier et souris
 */
class InputManager {
    constructor(game) {
        this.game = game;
        this.keys = {};
        this.mouse = { x: 0, y: 0, down: false };
        this.setupListeners();
    }

    setupListeners() {
        window.addEventListener('keydown', e => this.handleKeyDown(e));
        window.addEventListener('keyup', e => this.handleKeyUp(e));
        window.addEventListener('mousemove', e => this.handleMouseMove(e));
        window.addEventListener('mousedown', e => this.handleMouseDown(e));
        window.addEventListener('mouseup', e => this.handleMouseUp(e));
        window.addEventListener('contextmenu', e => e.preventDefault());
        window.addEventListener('wheel', e => this.handleWheel(e), { passive: false });
    }

    handleKeyDown(e) {
        if (e.key === 'Tab') {
            e.preventDefault();
            return;
        }
        const key = e.key.toLowerCase();
        this.keys[key] = true;

        if (key === 'e' && !this.game.paused) {
            this.game.toggleInventory();
        } else if (key === 'escape') {
            this.game.handleEscape();
        }
    }

    handleKeyUp(e) {
        this.keys[e.key.toLowerCase()] = false;
    }

    handleMouseMove(e) {
        this.mouse.x = e.clientX;
        this.mouse.y = e.clientY;
        this.game.updateDragPosition(e.clientX, e.clientY);
    }

    handleMouseDown(e) {
        if (this.game.paused || this.game.inventoryOpen) return;
        
        if (e.button === 0) this.mouse.down = true;
        if (e.button === 2) this.game.placeBlock();
    }

    handleMouseUp(e) {
        if (e.button === 0) this.mouse.down = false;
    }

    handleWheel(e) {
        if (this.game.paused || this.game.inventoryOpen) {
            e.preventDefault();
            return;
        }
        
        e.preventDefault();
        const delta = e.deltaY > 0 ? 1 : -1;
        this.game.inventory.changeSelection(delta);
        this.game.updateUI();
    }
}

/**
 * Classe principale du jeu
 */
class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        
        this.player = {
            x: 75,
            y: 30,
            vx: 0,
            vy: 0,
            width: CONSTANTS.PLAYER_WIDTH,
            height: CONSTANTS.PLAYER_HEIGHT,
            onGround: false,
            lastJumpTime: 0,
            jumpDelay: 500,
            scaleX: 1,
            scaleY: 1,
            squashForce: 0
        };
        
        this.saplings = [];
        this.droppedItems = []; // Items tombés au sol

        this.inventory = new InventoryManager(CONSTANTS.INVENTORY_SIZE, CONSTANTS.HOTBAR_SIZE);
        this.chunkManager = new ChunkManager(CONSTANTS.WORLD_SEED);
        this.renderer = new Renderer(this.canvas, this);
        this.input = new InputManager(this);

        // État du jeu
        this.paused = false;
        this.inventoryOpen = false;
        this.camera = { x: 0, y: 0 };
        this.miningCooldown = 0;
        this.lastTime = performance.now();
        this.dt = 1;

        // Grille de craft 3x3
        this.craftingGrid = Array(9).fill(null); // 9 slots pour la grille 3x3

        // Items de départ
        this.inventory.addItem(1, 5);  // Terre
        this.inventory.addItem(2, 5);  // Pierre
        this.inventory.addItem(11, 10); // Torches

        this.init();
    }

    init() {
        window.addEventListener('resize', () => this.renderer.resize());
        this.renderer.resize();
        this.updateUI();
        this.gameLoop();
    }

    togglePause() {
        if (this.paused) {
            document.getElementById('seedInput').value = this.chunkManager.seed;
        }
        this.paused = !this.paused;
        document.getElementById('pauseOverlay').classList.toggle('show', this.paused);
    }

    regenerateWorld(newSeed) {
        if (newSeed === "" || newSeed === undefined) return;
        
        // 1. Mettre à jour le seed dans les constantes et le manager
        const seed = parseInt(newSeed);
        this.chunkManager = new ChunkManager(seed);
        
        // 2. Réinitialiser la position du joueur (pour éviter de spawn dans un mur)
        this.player.x = 75;
        this.player.y = 30;
        this.player.vx = 0;
        this.player.vy = 0;
        
        // 3. Vider les entités temporaires
        this.droppedItems = [];
        this.saplings = [];
        
        // 4. Mettre à jour l'UI du seed pour l'utilisateur
        document.getElementById('seedInput').value = seed;
        
        // 5. Fermer la pause et redessiner
        this.togglePause();
        console.log("Monde régénéré avec le seed:", seed);
    }

    toggleInventory() {
        // Si on ferme l'inventaire, remettre les items de craft dans l'inventaire
        if (this.inventoryOpen) {
            this.returnCraftItemsToInventory();
            this.hideTooltip();
        }
        
        this.inventoryOpen = !this.inventoryOpen;
        const grid = document.getElementById('inventoryGrid');
        const panel = document.getElementById('craftingPanel');
        
        grid.classList.toggle('show', this.inventoryOpen);
        panel.style.display = this.inventoryOpen ? 'block' : 'none';
        
        if (this.inventoryOpen) this.updateCrafting();
    }

    handleEscape() {
        if (this.inventoryOpen) {
            this.returnCraftItemsToInventory();
            this.inventoryOpen = false;
            document.getElementById('inventoryGrid').classList.remove('show');
            document.getElementById('craftingPanel').style.display = 'none';
            this.hideTooltip();
        } else {
            this.togglePause();
        }
    }

    updateDragPosition(x, y) {
        const dragSlot = document.getElementById('dragSlot');
        if (this.inventory.draggedItem) {
            dragSlot.style.left = x + 'px';
            dragSlot.style.top = y + 'px';
        }
    }

    /**
     * Met à jour la physique du joueur
     */
    update() {
        const currentTime = Date.now();
        
        this.dt = Math.min((performance.now() - this.lastTime) / 16.6, 3);
        this.lastTime = performance.now();

        // On fait revenir les échelles vers 1 progressivement (effet élastique)
        this.player.scaleX += (1 - this.player.scaleX) * 0.2;
        this.player.scaleY += (1 - this.player.scaleY) * 0.2;

        // Si on vient de toucher le sol (atterrissage)
        if (this.player.onGround && this.player.vy === 0 && this.player.scaleY === 1) {
            // On pourrait ajouter un petit squash ici si on vient d'une chute rapide
        }

        if (this.paused || this.inventoryOpen) return;
        
        this.updateSaplings();
        this.updateDroppedItems();
        this.handleMovement(currentTime);
        this.handleMining();
        this.updateCamera();
    }

    handleMovement(currentTime) {
        const speed = CONSTANTS.SPEED * this.dt;
        const gravity = CONSTANTS.GRAVITY * this.dt;

        // Vérifier si le joueur est sur une échelle
        const playerBlockX = Math.floor(this.player.x);
        const playerBlockY = Math.floor(this.player.y + this.player.height / 2);
        const onLadder = this.getBlock(playerBlockX, playerBlockY).climbable;

        // Mouvement horizontal
        if (this.input.keys['q'] || this.input.keys['arrowleft']) {
            this.player.vx = -speed;
        } else if (this.input.keys['d'] || this.input.keys['arrowright']) {
            this.player.vx = speed;
        } else {
            this.player.vx = 0;
        }

        // Grimper sur l'échelle
        if (onLadder) {
            this.player.vy = 0; // Annuler la gravité
            
            if (this.input.keys['z'] || this.input.keys[' '] || this.input.keys['arrowup']) {
                this.player.vy = -speed * 1.2; // Grimper
            } else if (this.input.keys['s'] || this.input.keys['arrowdown']) {
                this.player.vy = speed * 1.2; // Descendre
            }
        } else { // Saut (uniquement si pas sur échelle)
            if ((this.input.keys['z'] || this.input.keys[' '] || this.input.keys['arrowup']) && this.player.onGround && 
    (currentTime - this.player.lastJumpTime) > this.player.jumpDelay) {
                this.player.vy = CONSTANTS.JUMP_FORCE;
                this.player.onGround = false;
                this.player.lastJumpTime = currentTime;
                //effet de saut
                this.player.scaleX = 0.7; // Plus mince
                this.player.scaleY = 1.3; // Plus grand
            }

            // Gravité (uniquement si pas sur échelle)
            this.player.vy += gravity;
        }

        // Application du mouvement
        this.moveX(this.player.vx);
        this.moveY(this.player.vy);
    }

    moveX(dx) {
        const hw = this.player.width / 2;
        const nextX = this.player.x + dx;
        const sideX = Math.floor(nextX + (dx > 0 ? hw : -hw));

        for (let y = Math.floor(this.player.y); y <= Math.floor(this.player.y + this.player.height); y++) {
            if (this.getBlock(sideX, y).solid) {
                this.player.vx = 0;
                return;
            }
        }
        this.player.x = nextX;
    }

    moveY(dy) {
        const hw = this.player.width / 2;
        const nextY = this.player.y + dy;

        if (dy > 0) {
            // Chute
            const bottomY = Math.floor(nextY + this.player.height);
            for (let x = Math.floor(this.player.x - hw); x <= Math.floor(this.player.x + hw); x++) {
                if (this.getBlock(x, bottomY).solid) {
                
                    // --- EFFET SQUASH ---
                    // Si on n'était pas au sol et qu'on tombe assez vite
                    if (!this.player.onGround && dy > 0.1) {
                        this.player.scaleX = 1.3; // S'élargit
                        this.player.scaleY = 0.7; // S'écrase
                    }
                    // --------------------
                    
                    this.player.y = bottomY - this.player.height - 0.01;
                    this.player.vy = 0;
                    this.player.onGround = true;
                    return;
                }
            }
        } else {
            // Saut
            const topY = Math.floor(nextY);
            for (let x = Math.floor(this.player.x - hw); x <= Math.floor(this.player.x + hw); x++) {
                if (this.getBlock(x, topY).solid) {
                    this.player.y = topY + 1 + 0.01;
                    this.player.vy = 0;
                    return;
                }
            }
        }
        
        this.player.y = nextY;
        this.player.onGround = false;
    }

    getBlock(x, y) {
        const blockId = this.chunkManager.getBlockId(Math.floor(x), Math.floor(y));
        return BLOCK_TYPES[blockId] || { solid: false };
    }

    updateCamera() {
        this.camera.x = this.player.x - this.renderer.viewWidth / 2;
        this.camera.y = Math.max(
            0,
            Math.min(
                this.player.y - this.renderer.viewHeight / 2,
                CONSTANTS.WORLD_HEIGHT - this.renderer.viewHeight
            )
        );
    }

    handleMining() {
        if (this.miningCooldown > 0) {
            this.miningCooldown -= this.dt;
        }
        
        if (this.input.mouse.down && this.miningCooldown <= 0) {
            this.mineBlock();
            this.miningCooldown = CONSTANTS.MINING_COOLDOWN;
        }
    }

    mineBlock() {
        const wx = Math.floor(this.camera.x + this.input.mouse.x / CONSTANTS.BLOCK_SIZE);
        const wy = Math.floor(this.camera.y + this.input.mouse.y / CONSTANTS.BLOCK_SIZE);
        
        const dx = wx + 0.5 - this.player.x;
        const dy = wy + 0.5 - (this.player.y + 0.5);
        
        if (Math.sqrt(dx * dx + dy * dy) > CONSTANTS.REACH_DISTANCE) return;

        const id = this.chunkManager.getBlockId(wx, wy);
        if (id && id !== 0 && !BLOCK_TYPES[id].unbreakable) {
            // Faire tomber l'item au sol
            this.dropItem(wx + 0.5, wy + 0.5, id, 1);
            
            this.chunkManager.setBlockId(wx, wy, 0);
            
            // Vérifier et casser les torches adjacentes qui n'ont plus de support
            this.checkAndBreakUnsupportedTorches(wx, wy);
            
            this.updateUI();
        }
    }

    /**
     * Vérifie et casse les torches adjacentes qui n'ont plus de support
     */
    checkAndBreakUnsupportedTorches(wx, wy) {
        // Vérifier les 4 blocs adjacents
        const adjacent = [
            { x: wx - 1, y: wy },  // Gauche
            { x: wx + 1, y: wy },  // Droite
            { x: wx, y: wy - 1 },  // Haut
            { x: wx, y: wy + 1 }   // Bas
        ];

        adjacent.forEach(pos => {
            const blockId = this.chunkManager.getBlockId(pos.x, pos.y);
            
            // Si c'est une torche
            if (blockId === 11) {
                // Vérifier si elle a encore un bloc solide adjacent
                const hasSupport = 
                    this.getBlock(pos.x - 1, pos.y).solid ||
                    this.getBlock(pos.x + 1, pos.y).solid ||
                    this.getBlock(pos.x, pos.y - 1).solid ||
                    this.getBlock(pos.x, pos.y + 1).solid;
                
                // Si plus de support, la faire tomber
                if (!hasSupport) {
                    this.dropItem(pos.x + 0.5, pos.y + 0.5, 11, 1);
                    this.chunkManager.setBlockId(pos.x, pos.y, 0);
                }
            }
        });
    }

    /**
     * Fait tomber un item au sol
     */
    dropItem(x, y, id, count) {
        this.droppedItems.push({
            x: x,
            y: y,
            vx: (Math.random() - 0.5) * 0.1, // Petite vélocité horizontale aléatoire
            vy: -0.05, // Petite impulsion vers le haut
            id: id,
            count: count,
            spawnTime: performance.now(),
            lifetime: 60000 // 60 secondes
        });
    }

    placeBlock() {
        const wx = Math.floor(this.camera.x + this.input.mouse.x / CONSTANTS.BLOCK_SIZE);
        const wy = Math.floor(this.camera.y + this.input.mouse.y / CONSTANTS.BLOCK_SIZE);

        const dx = wx + 0.5 - this.player.x;
        const dy = wy + 0.5 - (this.player.y + 0.5);
        
        if (Math.sqrt(dx * dx + dy * dy) > CONSTANTS.REACH_DISTANCE) return;
        if (this.chunkManager.getBlockId(wx, wy) !== 0) return;

        const selectedItem = this.inventory.getSelectedItem();
        if (!selectedItem || selectedItem.count <= 0) return;

        const blockData = BLOCK_TYPES[selectedItem.id];
        
        // Vérification spéciale pour les boutures
        if (selectedItem.id === 12) {
            const below = this.chunkManager.getBlockId(wx, wy + 1);
            if (![1, 3].includes(below)) return;
        }
        
        // Vérification spéciale pour les torches (doivent être adjacentes à un bloc solide)
        if (selectedItem.id === 11) {
            const hasAdjacentBlock = 
                this.getBlock(wx - 1, wy).solid ||  // Gauche
                this.getBlock(wx + 1, wy).solid ||  // Droite
                this.getBlock(wx, wy + 1).solid;    // Bas
            
            if (!hasAdjacentBlock) return; // Ne pas placer si aucun bloc adjacent
        }
        
        if (blockData.isItem) return; // Empêche de poser les items (bâtons)

        this.chunkManager.setBlockId(wx, wy, selectedItem.id);
        if (selectedItem.id === 12) {
            this.saplings.push({
                x: wx,
                y: wy,
                time: performance.now() + 5000 + Math.random() * 8000
            });
        }
        selectedItem.count--;

        if (selectedItem.count <= 0) {
            this.inventory.slots[this.inventory.selectedSlot] = null;
        }
        
        this.updateUI();
        this.updateCrafting();
    }

    /**
     * Système de craft avec grille 3x3
     */
    updateCrafting() {
        const panel = document.getElementById('craftingPanel');
        const grid = document.getElementById('craftingGrid');

        if (!this.inventoryOpen) {
            panel.style.display = 'none';
            return;
        }

        panel.style.display = 'block';
        
        // Créer la grille 3x3 si elle n'existe pas encore
        if (grid.children.length === 0) {
            for (let i = 0; i < 9; i++) {
                const slot = document.createElement('div');
                slot.className = 'craft-slot';
                
                slot.onmousedown = (e) => {
                    e.preventDefault();
                    let clickType = 'left';
                    if (e.button === 0) clickType = 'left';
                    else if (e.button === 1) clickType = 'middle';
                    else if (e.button === 2) clickType = 'right';
                    
                    this.handleCraftSlotClick(i, clickType);
                };
                
                slot.oncontextmenu = (e) => e.preventDefault(); // Empêcher le menu contextuel
                
                slot.onmouseenter = (e) => {
                    if (this.craftingGrid[i]) {
                        this.showTooltip(e, this.craftingGrid[i].id);
                    }
                };
                slot.onmousemove = (e) => this.moveTooltip(e);
                slot.onmouseleave = () => this.hideTooltip();
                
                grid.appendChild(slot);
            }
            
            // Bouton craft
            const craftBtn = document.getElementById('craftButton');
            craftBtn.onclick = () => this.executeCraft();
        }

        // Mettre à jour l'affichage de la grille
        this.renderCraftingGrid();
        this.checkRecipe();
    }

    renderCraftingGrid() {
        const grid = document.getElementById('craftingGrid');
        
        this.craftingGrid.forEach((item, i) => {
            const slot = grid.children[i];
            if (item) {
                slot.innerHTML = `${this.getIconHTML(item.id)}<span class="inv-count">${item.count}</span>`;
            } else {
                slot.innerHTML = '';
            }
        });
    }

    handleCraftSlotClick(index, clickType = 'left') {
        this.hideTooltip();
        
        const slotContent = this.craftingGrid[index];
        
        if (clickType === 'middle' && slotContent && !this.inventory.draggedItem) {
            // Clic molette : diviser le stack en deux
            const halfCount = Math.floor(slotContent.count / 2);
            if (halfCount > 0) {
                this.inventory.draggedItem = { id: slotContent.id, count: halfCount };
                slotContent.count -= halfCount;
                if (slotContent.count <= 0) {
                    this.craftingGrid[index] = null;
                }
            }
            this.updateUI();
            this.updateCrafting();
            return;
        }
        
        if (clickType === 'right') {
            if (this.inventory.draggedItem && !slotContent) {
                // Clic droit : déposer un seul item
                this.craftingGrid[index] = { id: this.inventory.draggedItem.id, count: 1 };
                this.inventory.draggedItem.count--;
                if (this.inventory.draggedItem.count <= 0) {
                    this.inventory.draggedItem = null;
                }
            } else if (this.inventory.draggedItem && slotContent && slotContent.id === this.inventory.draggedItem.id) {
                // Clic droit sur stack existant : ajouter 1
                slotContent.count++;
                this.inventory.draggedItem.count--;
                if (this.inventory.draggedItem.count <= 0) {
                    this.inventory.draggedItem = null;
                }
            } else if (!this.inventory.draggedItem && slotContent) {
                // Clic droit sur un slot plein : prendre la moitié
                const halfCount = Math.ceil(slotContent.count / 2);
                this.inventory.draggedItem = { id: slotContent.id, count: halfCount };
                slotContent.count -= halfCount;
                if (slotContent.count <= 0) {
                    this.craftingGrid[index] = null;
                }
            }
            this.updateUI();
            this.updateCrafting();
            return;
        }
        
        // Clic gauche (comportement par défaut)
        if (this.inventory.draggedItem && this.craftingGrid[index]) {
            // Si même item, fusionner les stacks
            if (this.craftingGrid[index].id === this.inventory.draggedItem.id) {
                this.craftingGrid[index].count += this.inventory.draggedItem.count;
                this.inventory.draggedItem = null;
            } else {
                // Échanger les items
                const temp = this.craftingGrid[index];
                this.craftingGrid[index] = this.inventory.draggedItem;
                this.inventory.draggedItem = temp;
            }
        } else if (this.inventory.draggedItem) {
            // Placer l'item dragué
            this.craftingGrid[index] = this.inventory.draggedItem;
            this.inventory.draggedItem = null;
        } else if (this.craftingGrid[index]) {
            // Prendre l'item
            this.inventory.draggedItem = this.craftingGrid[index];
            this.craftingGrid[index] = null;
        }
        
        this.updateUI();
        this.updateCrafting();
    }

    checkRecipe() {
        const outputSlot = document.getElementById('craftOutputSlot');
        const craftBtn = document.getElementById('craftButton');
        
        // Convertir la grille en pattern 3x3
        const currentPattern = [];
        for (let row = 0; row < 3; row++) {
            currentPattern[row] = [];
            for (let col = 0; col < 3; col++) {
                const index = row * 3 + col;
                currentPattern[row][col] = this.craftingGrid[index]?.id || null;
            }
        }

        // Chercher une recette qui correspond
        let matchedRecipe = null;
        
        for (const recipe of RECIPES) {
            if (this.patternsMatch(currentPattern, recipe.pattern)) {
                matchedRecipe = recipe;
                break;
            }
        }

        if (matchedRecipe) {
            outputSlot.innerHTML = `${this.getIconHTML(matchedRecipe.output.id)}<span class="inv-count">${matchedRecipe.output.count}</span>`;
            craftBtn.disabled = false;
            this.currentRecipe = matchedRecipe;
        } else {
            outputSlot.innerHTML = '';
            craftBtn.disabled = true;
            this.currentRecipe = null;
        }
    }

    patternsMatch(current, recipe) {
        // Vérifier correspondance exacte
        for (let row = 0; row < 3; row++) {
            for (let col = 0; col < 3; col++) {
                if (current[row][col] !== recipe[row][col]) {
                    return false;
                }
            }
        }
        return true;
    }

    executeCraft() {
        if (!this.currentRecipe) return;

        // Consommer les items de la grille
        this.craftingGrid.forEach((item, i) => {
            if (item) {
                item.count--;
                if (item.count <= 0) {
                    this.craftingGrid[i] = null;
                }
            }
        });

        // Ajouter le résultat à l'inventaire
        this.inventory.addItem(this.currentRecipe.output.id, this.currentRecipe.output.count);

        // Mettre à jour l'affichage
        this.updateUI();
        this.updateCrafting();
    }

    returnCraftItemsToInventory() {
        // Remettre tous les items de la grille de craft dans l'inventaire
        this.craftingGrid.forEach((item, i) => {
            if (item) {
                this.inventory.addItem(item.id, item.count);
                this.craftingGrid[i] = null;
            }
        });
        this.updateUI();
    }

    /*
    * gestion des pousses d'arbres
    */

    updateSaplings() {
        const now = performance.now();

        this.saplings = this.saplings.filter(s => {
            if (now < s.time) return true;

            // Vérifier que la bouture existe encore
            if (this.chunkManager.getBlockId(s.x, s.y) !== 12) return false;

            // Vérifier le sol
            const soil = this.chunkManager.getBlockId(s.x, s.y + 1);
            if (![1, 3].includes(soil)) return false;

            // Faire pousser l'arbre
            const { chunkX, localX } = this.chunkManager.worldToChunk(s.x);
            const chunk = this.chunkManager.get(chunkX);

            // Supprimer la bouture
            this.chunkManager.setBlockId(s.x, s.y, 0);

            // Générer l'arbre
            this.chunkManager.generateTree(chunk, localX, s.y + 1, s.x);

            return false; // retirer de la liste
        });
    }

    /**
     * Met à jour les items tombés au sol
     */
    updateDroppedItems() {
        const now = performance.now();
        const gravity = CONSTANTS.GRAVITY * this.dt;

        this.droppedItems = this.droppedItems.filter(item => {
            // Supprimer si le temps de vie est écoulé
            if (now - item.spawnTime > item.lifetime) return false;

            // Appliquer la gravité
            item.vy += gravity;

            // Appliquer la friction horizontale
            item.vx *= 0.95;

            // Mouvement horizontal
            const nextX = item.x + item.vx;
            const checkX = Math.floor(nextX);
            const checkY = Math.floor(item.y);
            
            if (!this.getBlock(checkX, checkY).solid) {
                item.x = nextX;
            } else {
                item.vx = 0;
            }

            // Mouvement vertical
            const nextY = item.y + item.vy;
            const bottomY = Math.floor(nextY + 0.2);
            
            if (this.getBlock(Math.floor(item.x), bottomY).solid) {
                item.y = bottomY - 0.2;
                item.vy = 0;
            } else {
                item.y = nextY;
            }

            // Vérifier si le joueur ramasse l'item
            const dx = item.x - this.player.x;
            const dy = item.y - (this.player.y + this.player.height / 2);
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < 1.5) {
                this.inventory.addItem(item.id, item.count);
                this.updateUI();
                return false; // Supprimer l'item
            }

            return true; // Garder l'item
        });
    }


    /**
     * Gestion de l'UI
     */
    updateUI() {
        this.renderHotbar();
        this.renderInventoryGrid();
        this.updateDragSlot();
    }

    renderHotbar() {
        const hotbar = document.getElementById('inventoryBar');
        hotbar.innerHTML = '';

        for (let i = 0; i < this.inventory.hotbarSize; i++) {
            const item = this.inventory.slots[i];
            const slot = this.createSlotElement(item, i === this.inventory.selectedSlot, 'inv-slot');
            this.attachTooltipEvents(slot, item);
            hotbar.appendChild(slot);
        }
    }

    renderInventoryGrid() {
        const grid = document.getElementById('inventoryGrid');
        grid.innerHTML = '';

        this.inventory.slots.forEach((item, i) => {
            const slot = this.createSlotElement(item, false, `inv-slot-grid ${i < 5 ? 'hotbar-sync' : ''}`);
            
            slot.onmousedown = (e) => {
                e.preventDefault();
                this.hideTooltip();
                
                let clickType = 'left';
                if (e.button === 0) clickType = 'left';
                else if (e.button === 1) clickType = 'middle';
                else if (e.button === 2) clickType = 'right';
                
                this.inventory.handleSlotClick(i, clickType);
                this.updateUI();
            };
            
            slot.oncontextmenu = (e) => e.preventDefault(); // Empêcher le menu contextuel
            
            this.attachTooltipEvents(slot, item);
            grid.appendChild(slot);
        });
    }

    createSlotElement(item, isSelected, className) {
        const slot = document.createElement('div');
        slot.className = className + (isSelected ? ' selected' : '');
        
        if (item) {
            slot.innerHTML = `${this.getIconHTML(item.id)}<span class="inv-count">${item.count}</span>`;
        }
        
        return slot;
    }

    getIconHTML(id) {
        if (id === 10) return `<div class="pixel-icon icon-stick"></div>`;
        if (id === 11) return `<div class="pixel-icon icon-torch"></div>`;
        if (id=== 12) return '<div class="pixel-icon icon-sapling"></div>';
        if (id === 13) return `<div class="pixel-icon icon-ladder"></div>`;
        return `<div class="block-icon" style="background:${BLOCK_TYPES[id].color}"></div>`;
    }

    attachTooltipEvents(element, item) {
        element.onmouseenter = (e) => this.showTooltip(e, item?.id ?? null);
        element.onmousemove = (e) => this.moveTooltip(e);
        element.onmouseleave = () => this.hideTooltip();
    }

    updateDragSlot() {
        const dragSlot = document.getElementById('dragSlot');
        
        if (this.inventory.draggedItem) {
            dragSlot.innerHTML = this.getIconHTML(this.inventory.draggedItem.id);
            dragSlot.style.display = 'block';
            dragSlot.style.left = this.input.mouse.x + 'px';
            dragSlot.style.top = this.input.mouse.y + 'px';
        } else {
            dragSlot.style.display = 'none';
        }

        if (this.inventoryOpen) {
            this.updateCrafting();
        }
    }

    showTooltip(e, id) {
        if (id === null || this.inventory.draggedItem) return;
        const tooltip = document.getElementById('tooltip');
        tooltip.style.display = 'block';
        tooltip.innerText = BLOCK_TYPES[id].name;
        this.moveTooltip(e);
    }

    moveTooltip(e) {
        const tooltip = document.getElementById('tooltip');
        tooltip.style.left = (e.clientX + 15) + 'px';
        tooltip.style.top = (e.clientY - 30) + 'px';
    }

    hideTooltip() {
        const tooltip = document.getElementById('tooltip');
        if (tooltip) tooltip.style.display = 'none';
    }

    /**
     * Boucle principale
     */
    gameLoop() {
        this.update();
        this.renderer.render(this.camera, this.player, this.chunkManager, this.inventory, this.saplings);
        requestAnimationFrame(() => this.gameLoop());
    }
}

// Démarrage du jeu
const game = new Game();
</script>
</body>
</html>
